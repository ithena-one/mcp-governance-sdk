# Interfaces for Extensibility

**Navigation:**
* [← Back to Configuration](./configuration.md)
* [Next: Authorization →](./authorization.md)

The `@ithena/mcp-governance` SDK is designed to be pluggable. You integrate it with your existing infrastructure (Identity Providers, Secret Managers, Logging/Auditing systems) by implementing these core interfaces and providing them in the `GovernedServerOptions`.

## `IdentityResolver`

*   **File:** `src/interfaces/identity.ts`
*   **Purpose:** Determines the identity of the user or system making the MCP request. This is the foundation for authentication and authorization.
*   **Methods:**
    *   `initialize?(): Promise<void>`: (Optional) Called once during `GovernedServer.connect()`. Use for setup like initializing SDKs or warming caches. Throw an error to abort connection.
    *   `resolveIdentity(opCtx: OperationContext): Promise<UserIdentity | null>`:
        *   **Required.** Called for every request (and optionally for notifications).
        *   Examine `opCtx.transportContext` (e.g., `headers`, `remoteAddress`) and potentially `opCtx.mcpMessage` to extract authentication credentials (like JWT from `Authorization` header, API key, session cookie, mTLS certificate info, etc.).
        *   Validate the credentials against your identity provider or system.
        *   Return a `UserIdentity` (string or object with `id`) upon successful authentication.
        *   Return `null` if no identity can be determined (anonymous access, if allowed).
        *   Throw an `AuthenticationError` (or a subclass) if authentication fails (e.g., invalid token, bad password). This usually stops the request pipeline.
    *   `shutdown?(): Promise<void>`: (Optional) Called once during `GovernedServer.close()`. Use for cleanup like closing connections. Should not throw errors.
*   **Implementation Notes:** This is a critical security component. Ensure robust validation of credentials. Common patterns include validating JWTs, introspecting OAuth tokens, or verifying API keys against a database. **Never trust headers like `X-User-ID` directly in production without validation.**

## `RoleStore`

*   **File:** `src/interfaces/rbac.ts`
*   **Purpose:** Retrieves the list of roles associated with a successfully resolved identity. Required if `enableRbac` is true.
*   **Methods:**
    *   `initialize?(): Promise<void>`: (Optional) Setup logic.
    *   `getRoles(identity: UserIdentity, opCtx: OperationContext): Promise<string[]>`:
        *   **Required if RBAC enabled.** Called after identity resolution.
        *   Takes the `UserIdentity` returned by `IdentityResolver`.
        *   Query your authorization system (e.g., LDAP groups, database table, IDP claims) to find the roles assigned to this identity.
        *   Return an array of role strings (e.g., `['admin', 'editor']`). Return an empty array `[]` if the user has no roles.
    *   `shutdown?(): Promise<void>`: (Optional) Cleanup logic.
*   **Implementation Notes:** Map the `UserIdentity` to roles defined in your system.

## `PermissionStore`

*   **File:** `src/interfaces/rbac.ts`
*   **Purpose:** Checks if a given role possesses a specific permission required for an operation. Required if `enableRbac` is true.
*   **Methods:**
    *   `initialize?(): Promise<void>`: (Optional) Setup logic.
    *   `hasPermission(role: string, permission: string, opCtx: OperationContext): Promise<boolean>`:
        *   **Required if RBAC enabled.** Called during RBAC checks for each role the user has.
        *   `role`: A single role string from the list returned by `RoleStore`.
        *   `permission`: The permission string generated by `derivePermission` (e.g., `tool:call:my_tool`).
        *   Check if the specified `role` grants the specified `permission` according to your system's rules (e.g., check a permissions database, policy engine).
        *   Return `true` if the permission is granted, `false` otherwise.
    *   `shutdown?(): Promise<void>`: (Optional) Cleanup logic.
*   **Implementation Notes:** Can implement simple role-to-permission mapping or integrate with more complex policy engines (like OPA). Consider supporting wildcards (e.g., `resource:read:*`) if needed.

## `CredentialResolver`

*   **File:** `src/interfaces/credentials.ts`
*   **Purpose:** Securely fetches sensitive credentials (API keys, tokens, passwords) that your MCP handlers (tools, resources) might need to interact with other systems.
*   **Methods:**
    *   `initialize?(): Promise<void>`: (Optional) Setup logic (e.g., connect to secrets manager).
    *   `resolveCredentials(identity: UserIdentity | null, opCtx: OperationContext): Promise<ResolvedCredentials | null | undefined>`:
        *   **Optional.** Called after successful authorization (if RBAC is enabled) or after identity resolution (if RBAC is disabled).
        *   Receives the resolved `identity` (or null) and the `OperationContext`.
        *   Determine which credentials are needed based on the operation (`opCtx.mcpMessage`) or the user (`identity`).
        *   Fetch secrets securely from your secrets management system (e.g., HashiCorp Vault, AWS Secrets Manager, Azure Key Vault). **Avoid hardcoding secrets.**
        *   Return a `ResolvedCredentials` object (a `Record<string, any>`) containing the fetched secrets.
        *   Return `null` or `undefined` if no credentials are required for this operation/identity.
        *   Throw a `CredentialResolutionError` if required credentials cannot be fetched. This may fail the request depending on the `failOnCredentialResolutionError` option.
    *   `shutdown?(): Promise<void>`: (Optional) Cleanup logic (e.g., close connection to secrets manager).
*   **Implementation Notes:** Focus on secure retrieval and avoid exposing secrets unnecessarily. The returned credentials object is passed directly to your handler via `GovernedRequestHandlerExtra`.

## `AuditLogStore`

*   **File:** `src/interfaces/audit.ts`
*   **Purpose:** Receives detailed audit records for storage and analysis, typically in a SIEM, database, or log aggregation platform.
*   **Methods:**
    *   `initialize?(): Promise<void>`: (Optional) Setup logic (e.g., establish connection to logging platform).
    *   `log(record: AuditRecord): Promise<void>`:
        *   **Required for Auditing.** Called asynchronously at the end of the pipeline.
        *   Receives the complete, potentially *sanitized* `AuditRecord`.
        *   Implement logic to send this record to your auditing system (e.g., Splunk, Elasticsearch, database).
        *   **Important:** This method should handle its own errors gracefully (e.g., log to console) and *not* throw errors that would disrupt the main MCP request flow.
    *   `shutdown?(): Promise<void>`: (Optional) Cleanup logic (e.g., flush buffered logs, close connections).
*   **Implementation Notes:** Implementations need to handle potential serialization issues and network failures when sending records. Consider batching or asynchronous sending for performance.

## `Logger`

*   **File:** `src/interfaces/logger.ts`
*   **Purpose:** Provides a standard interface for structured logging throughout the SDK and in your handlers.
*   **Methods:**
    *   `initialize?(): Promise<void>`: (Optional) Setup logic.
    *   `debug(message: string, context?: LogContext): void`
    *   `info(message: string, context?: LogContext): void`
    *   `warn(message: string, context?: LogContext): void`
    *   `error(message: string, error?: Error | unknown, context?: LogContext): void`
    *   `child?(bindings: LogContext): Logger`: (Optional but Recommended) Creates a new logger instance with additional context bound to it (e.g., `eventId`, `traceId`). Used by the SDK to create request-scoped loggers. If not provided, the same logger instance is used everywhere.
    *   `shutdown?(): Promise<void>`: (Optional) Cleanup logic (e.g., flush buffers).
*   **Implementation Notes:** Adapt your preferred Node.js logger (Pino, Winston, Bunyan) to this interface. Structured logging (using the `context` object) is highly recommended for better observability.

## `TraceContextProvider`

*   **File:** `src/interfaces/tracing.ts`
*   **Purpose:** Extracts distributed tracing information (like Trace IDs and Span IDs) from the incoming request context.
*   **Type:** A function type: `(transportContext: TransportContext, mcpMessage: Request | Notification) => TraceContext | undefined`
*   **Implementation Notes:** The default implementation (`defaultTraceContextProvider`) handles standard W3C Trace Context headers (`traceparent`, `tracestate`). Provide your own function if you use a different context propagation mechanism (e.g., B3 headers). The returned `TraceContext` is added to `OperationContext` and `AuditRecord`.

**Navigation:**
* [← Back to Configuration](./configuration.md)
* [Next: Authorization →](./authorization.md) 